
--------------------------------- CLONE -----------------------------------------

L'implementació del clone es similar a la del fork, amb la diferencia, primer de 
que el clone no crea una nova taula de paginas, ni copia la memoria de dades al 
fill, ja que en un mateix process la memoria es compartida, i segon, que el nou 
fill, ha de retornar a la funció especificada amb la pila especificada y amb el 
parametre especificat a la pila.

Per implementar aixo, he reciclar el codi del fork, eliminant la secció del codi 
encarregada de generar la nova taula de paginas, reservar nova memoria de dades 
y copiar les dades del pare. A diferencia del fork, per afegir el parametre a 
la nova pila s'han incorporat les linies:

	stack-=sizeof(unsigned long);
	*((long unsigned int*)stack) = parameter;
	stack-=sizeof(unsigned long);
	*((long unsigned int*)stack) = 0;
	
per posar la funció pasada i la pila passada al contexte hardware, de manera que
al tornar al contexte del nou fil retorni a la posició adequada amb la pila 
adequada, s'han incorporat les linies:
	
	unthread->stack[KERNEL_STACK_SIZE - 5] = function;
	unthread->stack[KERNEL_STACK_SIZE - 2] = stack;

*la variable stack ha sigut modificada al pas anterior, a l'hora de fer el "push"
del parametre y de una direcció de retorn nula, d'aquesta manera el esp hardware
no apuntara a la base, si no al top de la pila, com es requerit.

Finalment, com el fork no te parametres, s'han agut de incorporar les proves per
verificar que els parametres son correctes:

	if (!access_ok(VERIFY_READ, function, 1))
		return -EINVAL;

	if (!access_ok(VERIFY_WRITE, stack, 1))
		return -EINVAL;
		 
*el parametre no es necesari provar-ho, ja que un valor null (o cualsevol valor) 
es valid en aquest cas.

--------------------------------- EXIT -----------------------------------------

per a l'exit es necessari alliberar memoria unicament si no hi queda cap fil
del process, per comprovar aixo, es reocrre la lliste de task structs buscant
tots els processos que comparteixen taula de pagines amb el current, si hi ha 
cap actiu (PID != -1), no s'allibera la memoria, nomes en cas contrari s'allibera.


------------------------------ ALLOCATE_DIR ------------------------------------

Modificat allocate dir perque, nomes utilitzi taulas de pagina lliures. 
Implementat una llista de taules lliures, am punters a la llista original, per
allocar una nova taula agafa el primer element, i al exit, s'afegeix la taula del
process a la llista de nou. Una referencia al element de la llista que apunta a 
la taula del process es guarda al task_struct.

--------------------------------- ERRNO ----------------------------------------

mogut el errno al task_struct, ara accedir y modificar el errno es fa mitjancant 
trucades al sistema (get_errno, set_errno)

--------------------------------- TESTS ----------------------------------------

totes les proves, es troben a la carpeta tests, son copies de user.c, per
provar-ho, s'ha de copiar la prova pertinent a la base coma a user.c i compilar.

basic:
	prova un funcionament correcte de les funcions clone y exit, cuan es prem una
	tecla fa un clone, amb valors correctes de function y stack, y ambd el event_t
	coma parametre, la funció imprimeix la tecla pulsada per pantalla y fa exit.

	Per cada tecla, s'hauria de veure per pantalla la tecla impresa dues vegades
	(una per press un altre pre release).

stack-NULL:
	prova de la funció clone amb un valor de pila incorrecte.

	S'auria de veure "clone error: 14" 14 per EFAULT

function NULL:
	prova de la funció clone amb un valor de funció incorrecte.

	S'auria de veure "clone error: 14" 14 per EFAULT
	
errno syscalls:
	prova les syscall per llegir y modificar el errno, ambd dos trucades erronies
	de write, y dos perror despres de cada una.

	Auria de sortir per pantalla EBADF (9) y EFAULT (14)

errno overwrite:
	prova si el canvi del errno en un fil afecta a un altre, errno incial es 9,
	cada vegada que es prem una tecla un nou fil es crea y modifical l'errno a 14.

	No auria de cambiar l'errno del primer fil.

memoria compartida:
	prova que efectivament la memoria entre fils es compartida, modificant una
	variable global.

exit de un hilo no libera mem:
	prova que fer exit nomes dun fil no allibera la memoria, per comprovar-ho,
	es fa exit a un fil i s'accedeix a una global a un altre.

exit del segundo si libera mem:
	prova que fer exit de tots els fils allibera memoria, per comprovar-ho,
	es fa exit dels dos fils y vaig incorporar uns print de debug a exit, per
	veure si esta alliberant la memoria correctament.

no sobreesscriure pagina de tablas + fork a un fil:
	prova que un fork parallel a un fils que no tingui la taula de pagines a la
	mateixa posició que el task struct, no modificara la pagina de taules, a mes
	fa un fork dins d'un fil, fa un clone, y un exit de l'original, dins de la 
	funció del fil, fa tants forks com espai hi ha lliurr (fork fins ENOMEM), a 
	tots els forks sobreescriu una variable global, si la logica es correcta, cap 
	process auria d'haver escollit la taula del fil, y per tant el valor al fil 
	auria de ser el mateix que era.
